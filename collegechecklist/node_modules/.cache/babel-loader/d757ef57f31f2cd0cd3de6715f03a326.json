{"ast":null,"code":"import { constTasks } from '../StoredVar';\nexport const constTasksExist = selectedCollege => constTasks.find(task => task.key === selectedCollege);\nexport const generatePushId = (() => {\n  var PUSH_CHARS = \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\"; // Timestamp of last push, used to prevent local collisions if you push twice in one ms.\n\n  var lastPushTime = 0; // We generate 72-bits of randomness which get turned into 12 characters and appended to the\n  // timestamp to prevent collisions with other clients.  We store the last characters we\n  // generated because in the event of a collision, we'll use those same characters except\n  // \"incremented\" by one.\n\n  var lastRandChars = [];\n  return function () {\n    var now = new Date().getTime();\n    var duplicateTime = now === lastPushTime;\n    lastPushTime = now;\n    var timeStampChars = new Array(8);\n\n    for (var i = 7; i >= 0; i--) {\n      timeStampChars[i] = PUSH_CHARS.charAt(now % 64); // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n\n      now = Math.floor(now / 64);\n    }\n\n    if (now !== 0) throw new Error(\"We should have converted the entire timestamp.\");\n    var id = timeStampChars.join(\"\");\n\n    if (!duplicateTime) {\n      for (i = 0; i < 12; i++) {\n        lastRandChars[i] = Math.floor(Math.random() * 64);\n      }\n    } else {\n      // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n        lastRandChars[i] = 0;\n      }\n\n      lastRandChars[i]++;\n    }\n\n    for (i = 0; i < 12; i++) {\n      id += PUSH_CHARS.charAt(lastRandChars[i]);\n    }\n\n    if (id.length !== 20) throw new Error(\"Length should be 20.\");\n    return id;\n  };\n})();","map":{"version":3,"sources":["/Users/jordankillenberg/Documents/CollegeChecklist/collegechecklist/src/Helpers/index.jsx"],"names":["constTasks","constTasksExist","selectedCollege","find","task","key","generatePushId","PUSH_CHARS","lastPushTime","lastRandChars","now","Date","getTime","duplicateTime","timeStampChars","Array","i","charAt","Math","floor","Error","id","join","random","length"],"mappings":"AAAA,SAASA,UAAT,QAA2B,cAA3B;AAGA,OAAO,MAAMC,eAAe,GAAGC,eAAe,IAC5CF,UAAU,CAACG,IAAX,CAAgBC,IAAI,IAAIA,IAAI,CAACC,GAAL,KAAaH,eAArC,CADK;AAGP,OAAO,MAAMI,cAAc,GAAG,CAAC,MAAM;AACnC,MAAIC,UAAU,GACd,kEADA,CADmC,CAIrC;;AACA,MAAIC,YAAY,GAAG,CAAnB,CALqC,CAOrC;AACA;AACA;AACA;;AACA,MAAIC,aAAa,GAAG,EAApB;AAEA,SAAO,YAAW;AAChB,QAAIC,GAAG,GAAG,IAAIC,IAAJ,GAAWC,OAAX,EAAV;AACA,QAAIC,aAAa,GAAGH,GAAG,KAAKF,YAA5B;AACAA,IAAAA,YAAY,GAAGE,GAAf;AAEA,QAAII,cAAc,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAArB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;AAC3BF,MAAAA,cAAc,CAACE,CAAD,CAAd,GAAoBT,UAAU,CAACU,MAAX,CAAkBP,GAAG,GAAG,EAAxB,CAApB,CAD2B,CAE3B;;AACAA,MAAAA,GAAG,GAAGQ,IAAI,CAACC,KAAL,CAAWT,GAAG,GAAG,EAAjB,CAAN;AACD;;AACD,QAAIA,GAAG,KAAK,CAAZ,EACE,MAAM,IAAIU,KAAJ,CAAU,gDAAV,CAAN;AAEF,QAAIC,EAAE,GAAGP,cAAc,CAACQ,IAAf,CAAoB,EAApB,CAAT;;AAEA,QAAI,CAACT,aAAL,EAAoB;AAClB,WAAKG,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBP,QAAAA,aAAa,CAACO,CAAD,CAAb,GAAmBE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACK,MAAL,KAAgB,EAA3B,CAAnB;AACD;AACF,KAJD,MAIO;AACL;AACA,WAAKP,CAAC,GAAG,EAAT,EAAaA,CAAC,IAAI,CAAL,IAAUP,aAAa,CAACO,CAAD,CAAb,KAAqB,EAA5C,EAAgDA,CAAC,EAAjD,EAAqD;AACnDP,QAAAA,aAAa,CAACO,CAAD,CAAb,GAAmB,CAAnB;AACD;;AACDP,MAAAA,aAAa,CAACO,CAAD,CAAb;AACD;;AACD,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,EAAhB,EAAoBA,CAAC,EAArB,EAAyB;AACvBK,MAAAA,EAAE,IAAId,UAAU,CAACU,MAAX,CAAkBR,aAAa,CAACO,CAAD,CAA/B,CAAN;AACD;;AACD,QAAIK,EAAE,CAACG,MAAH,KAAc,EAAlB,EAAsB,MAAM,IAAIJ,KAAJ,CAAU,sBAAV,CAAN;AAEtB,WAAOC,EAAP;AACC,GAjCH;AAkCC,CA/C6B,GAAvB","sourcesContent":["import { constTasks } from '../StoredVar';\n\n\nexport const constTasksExist = selectedCollege =>\n  constTasks.find(task => task.key === selectedCollege);\n\nexport const generatePushId = (() => {\n  var PUSH_CHARS =\n  \"-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\";\n\n// Timestamp of last push, used to prevent local collisions if you push twice in one ms.\nvar lastPushTime = 0;\n\n// We generate 72-bits of randomness which get turned into 12 characters and appended to the\n// timestamp to prevent collisions with other clients.  We store the last characters we\n// generated because in the event of a collision, we'll use those same characters except\n// \"incremented\" by one.\nvar lastRandChars = [];\n\nreturn function() {\n  var now = new Date().getTime();\n  var duplicateTime = now === lastPushTime;\n  lastPushTime = now;\n\n  var timeStampChars = new Array(8);\n  for (var i = 7; i >= 0; i--) {\n    timeStampChars[i] = PUSH_CHARS.charAt(now % 64);\n    // NOTE: Can't use << here because javascript will convert to int and lose the upper bits.\n    now = Math.floor(now / 64);\n  }\n  if (now !== 0)\n    throw new Error(\"We should have converted the entire timestamp.\");\n\n  var id = timeStampChars.join(\"\");\n\n  if (!duplicateTime) {\n    for (i = 0; i < 12; i++) {\n      lastRandChars[i] = Math.floor(Math.random() * 64);\n    }\n  } else {\n    // If the timestamp hasn't changed since last push, use the same random number, except incremented by 1.\n    for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {\n      lastRandChars[i] = 0;\n    }\n    lastRandChars[i]++;\n  }\n  for (i = 0; i < 12; i++) {\n    id += PUSH_CHARS.charAt(lastRandChars[i]);\n  }\n  if (id.length !== 20) throw new Error(\"Length should be 20.\");\n\n  return id;\n  };\n})();"]},"metadata":{},"sourceType":"module"}